<?php


	namespace MehrIt\LaraDbExt\Query;


	use Illuminate\Database\Query\Builder;
	use Illuminate\Database\Query\Expression;
	use Illuminate\Database\Query\JoinClause;
	use Illuminate\Support\Arr;
	use Illuminate\Support\Str;
	use InvalidArgumentException;
	use MehrIt\LaraDbExt\Util\ChecksEmptyIterators;

	class UpdateWithJoinedData
	{
		use ChecksEmptyIterators;

		/**
		 * @var Builder
		 *
		 */
		protected $builder;

		/**
		 * @var string
		 */
		protected $dataTableName;

		/**
		 * @var string[]|Expression[]
		 */
		protected $updateFields = [];

		/**
		 * @var mixed|array|array[]
		 */
		protected $joinOn = ['id'];

		/**
		 * @var iterable[]
		 */
		protected $data;

		/**
		 * @var array
		 */
		protected $updateDefaultFields = [];

		/**
		 * Creates a new instance
		 * @param Builder $builder The Builder instance
		 * @param iterable $data The data to update
		 * @param array|array[] $joinOn Specifies the join conditions between the data table and the target table. Arrays are interpreted as multiple join conditions. Simple string item will join data based on the given field in both tables.
		 * @param string $dataTableName The data table alias
		 * @param Expression[]|string[]|mixed $updateFields The fields to update. Items with numeric indices are interpreted as field names. For other items the item value (or expression) is assigned to the field specified by the item key.
		 */
		public function __construct(Builder $builder, $data, array $joinOn = ['id'], $updateFields = [], string $dataTableName = 'data') {

			if ($this->isEmptyIterable($data))
				throw new InvalidArgumentException('Data must not be empty.');
			foreach($data as $index => $currRow) {
				if ($this->isEmptyIterable($currRow))
					throw new InvalidArgumentException("Data row at index {$index} is empty.");
			}
			if (count($joinOn) < 1)
				throw new InvalidArgumentException('At least one join condition is required');
			if (trim($dataTableName) === '')
				throw new InvalidArgumentException('The data table name must not be empty');


			$this->builder       = $builder;
			$this->dataTableName = $dataTableName;
			$this->updateFields  = $updateFields;
			$this->joinOn        = $joinOn;
			$this->data          = $data;

		}


		/**
		 * Executes the query
		 * @return int The number of affected rows
		 */
		public function execute() {

			$grammar = $this->builder->getGrammar();
			$targetTable = $this->builder->from;


			// compile join args and build list of target table fields which are used for joining (the won't be included into autogenerated update list)
			$targetJoinFields = [];
			$joinArgs         = [];
			foreach ($this->joinOn as $currJoin) {
				$currJoin = Arr::wrap($currJoin);

				if (count($currJoin) === 1 && is_string($field = Arr::first($currJoin))) {

					$targetField = Arr::first(array_keys($currJoin));
					if (is_int($targetField))
						$targetField = $field;


					$targetJoinFields[] = $targetField;

					$joinArgs[] = ["{$targetTable}.{$targetField}", '=', "{$this->dataTableName}.{$field}"];
				}
				else {

					// If the first argument is a string, this is the field name. We add it to the "target join fields" list (without table name).
					$currFirstArg = Arr::first($currJoin);
					if (is_string($currFirstArg))
						$targetJoinFields[] = preg_replace('/^' . preg_quote($targetTable, '/') . '\./', '', $currFirstArg);

					$joinArgs[] = $currJoin;
				}

			}


			// if no list of update fields is passed, we automatically generate an update list based on fields in the first data row
			$updateFields = $this->updateFields ?: $this->updateFieldNamesFromData($targetJoinFields);

			// merge with default field updates
			$updateFields = array_merge($this->updateDefaultFields, $updateFields);

			// build update list
			$update = [];
			foreach ($updateFields as $targetField => $field) {

				if (is_int($targetField)) {
					$update["{$targetTable}.{$field}"] = new Expression($grammar->wrap("{$this->dataTableName}.{$field}"));
				}
				else {

					// prepend target table, if table not given in field name
					if (!Str::contains($targetField, '.'))
						$targetField = "{$targetTable}.{$targetField}";

					$update[$targetField] = $field;
				}
			}



			return $this->builder
				->joinSub(
					function ($query) {
						/** @var Builder $query */

						$data = $this->data;

						// select first data row
						$firstRow = array_shift($data);
						$this->selectRowData($query, $firstRow);

						// append other data rows with union
						foreach($data as $currRow) {
							$query->unionAll(function($query) use ($currRow) {
								/** @var Builder $query */
								$this->selectRowData($query, $currRow);
							});
						}

					},
					$this->dataTableName,
					function($joinClause) use ($joinArgs) {
						/** @var JoinClause $joinClause */

						foreach($joinArgs as $currArgs) {
							$joinClause->on(...$currArgs);
						}

					}
				)
				->update($update);
		}

		/**
		 * Sets the default update fields
		 * @param array $updateDefaultFields The default update fields
		 * @return UpdateWithJoinedData
		 */
		public function setUpdateDefaultFields(array $updateDefaultFields): UpdateWithJoinedData {
			$this->updateDefaultFields = $updateDefaultFields;

			return $this;
		}



		/**
		 * Returns the update field names examining the fields of the first data row
		 * @param string[] $exclude The fields to exclude
		 * @return string[] The field names
		 */
		protected function updateFieldNamesFromData(array $exclude = []): array {

			$excludeMap = array_fill_keys($exclude, true);

			$row = Arr::first($this->data);


			$fieldNames = [];
			foreach ($row as $field => $v) {

				// skip, if the field has be equal do to join
				if (!($excludeMap[$field] ?? false))
					$fieldNames[] = $field;
			}

			return $fieldNames;
		}

		/**
		 * Adds the given row data to query's select list
		 * @param Builder $query The query to add select to
		 * @param iterable $row The row data
		 */
		protected function selectRowData($query, $row) {

			foreach($row as $alias => $value) {

				if ($value instanceof Expression) {
					$query->selectSub($value->getValue(), $alias);
				}
				else {
					$query
						->selectSub('?', $alias)
						->addBinding($value, 'select');
				}
			}

		}



	}