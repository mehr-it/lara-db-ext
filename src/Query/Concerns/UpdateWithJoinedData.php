<?php


	namespace MehrIt\LaraDbExt\Query\Concerns;


	use Illuminate\Contracts\Support\Arrayable;
	use Illuminate\Database\Query\Expression;
	use Illuminate\Database\Query\Grammars\Grammar;
	use Illuminate\Database\Query\JoinClause;
	use Illuminate\Support\Arr;
	use Illuminate\Support\Str;
	use InvalidArgumentException;
	use MehrIt\LaraDbExt\Query\Builder;
	use Traversable;

	trait UpdateWithJoinedData
	{
		/**
		 * Executes an update with given data joined as virtual table
		 * @param iterable[] $data The data to update
		 * @param array|array[] $joinOn Specifies the join conditions between the data table and the target table. Arrays are interpreted as multiple join conditions. Simple string item will join data based on the given field in both tables.
		 * @param Expression[]|string[]|mixed $updateFields The fields to update. Items with numeric indices are interpreted as field names. For other items the item value (or expression) is assigned to the field specified by the item key.
		 * @param string $dataTableName The data table alias
		 * @param Expression[]|string[]|mixed $additionalUpdateFields Update fields which are additionally applied
		 * @return int The number of affected rows
		 */
		public function updateWithJoinedData($data, array $joinOn = ['id'], $updateFields = [], string $dataTableName = 'data', array $additionalUpdateFields = []) {

			if (empty($joinOn))
				throw new InvalidArgumentException('At least one join condition must be specified');
			if (trim($dataTableName) === '')
				throw new InvalidArgumentException('Data table name must not be empty');

			if ($data instanceof Arrayable)
				$data = $data->toArray();
			elseif ($data instanceof Traversable)
				$data = iterator_to_array($data);

			$data = array_filter($data);

			if (empty($data))
				return 0;


			$grammar     = $this->getGrammar();
			$targetTable = $this->from;

			// compile join args and build list of target table fields which are used for joining (the won't be included into autogenerated update list)
			$targetJoinFields = [];
			$joinArgs         = [];
			foreach ($joinOn as $currJoin) {
				$currJoin = Arr::wrap($currJoin);

				if (count($currJoin) === 1 && is_string($field = Arr::first($currJoin))) {

					$targetField = Arr::first(array_keys($currJoin));
					if (is_int($targetField))
						$targetField = $field;


					$targetJoinFields[] = $targetField;

					$joinArgs[] = ["{$targetTable}.{$targetField}", '=', "{$dataTableName}.{$field}"];
				}
				else {

					// If the first argument is a string, this is the field name. We add it to the "target join fields" list (without table name).
					$currFirstArg = Arr::first($currJoin);
					if (is_string($currFirstArg))
						$targetJoinFields[] = preg_replace('/^' . preg_quote($targetTable, '/') . '\./', '', $currFirstArg);

					$joinArgs[] = $currJoin;
				}

			}


			// if no list of update fields is passed, we automatically generate an update list based on fields in the first data row
			if (!$updateFields) {
				$excludeFromUpdateMap = array_fill_keys($targetJoinFields, true);

				$updateFields = [];
				foreach (Arr::first($data) as $field => $v) {

					// skip, if the field has be equal do to join
					if (!($excludeFromUpdateMap[$field] ?? false))
						$updateFields[] = $field;
				}

			}

			// apply default update fields
			$updateFields = array_merge($additionalUpdateFields, $updateFields);


			// build update list
			$update = [];
			foreach ($updateFields as $targetField => $field) {

				if (is_int($targetField)) {
					$update["{$targetTable}.{$field}"] = new Expression($grammar->wrap("{$dataTableName}.{$field}"));
				}
				else {

					// prepend target table, if table not given in field name
					if (!Str::contains($targetField, '.'))
						$targetField = "{$targetTable}.{$targetField}";

					$update[$targetField] = $field;
				}
			}


			return
				$this->joinSub(
					function ($query) use ($data) {
						/** @var Builder $query */

						// select first data row
						$firstRow = array_shift($data);
						$this->dataToSelect($query, $firstRow);

						// append other data rows with union
						foreach ($data as $currRow) {
							$query->unionAll(function ($query) use ($currRow) {
								/** @var Builder $query */
								$this->dataToSelect($query, $currRow);
							});
						}

					},
					$dataTableName,
					function ($joinClause) use ($joinArgs) {
						/** @var JoinClause $joinClause */

						foreach ($joinArgs as $currArgs) {
							$joinClause->on(...$currArgs);
						}

					}
				)
				->update($update);
		}

		/**
		 * Adds the given row data to query's select
		 * @param Builder $query The query to add select to
		 * @param iterable $rowData The row data
		 */
		protected function dataToSelect($query, $rowData) {

			/** @var Grammar $grammar */
			$grammar = $this->getGrammar();

			foreach ($rowData as $alias => $value) {

				// arrays cause unexpected behaviour without error when passed to 'addBinding()', so we check here
				if (is_array($value))
					throw new \InvalidArgumentException("Data fields must not contain arrays. Array given for \"{$alias}\".");


				if ($value instanceof Expression) {
					$query->selectSub($grammar->getValue($value), $alias);
				}
				else {
					$query
						->selectSub('?', $alias)
						->addBinding($value, 'select');
				}
			}

		}

	}